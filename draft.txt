
***	edit by Hugo-Fu 2016.03.15 10:12 am


1.术语介绍：

ECS：实体组件系统架构，已成为开发游戏的主力设计模式

GameObject：游戏对象实体，在ECS中，没有类的概念，所有的对象都由组件组成，可以把此类看作组件的集合。

Component：存储不同的数据，是组成GameObject的基础单元。组件只存储数据，没有逻辑。

System：运行component的逻辑单元。系统只运行逻辑，不存储数据，每个系统只有一个实例。

Action：代表一个动作状态，由多个组件和系统构成。

data：定义游戏对象的数据表格，使用json格式。

time-scope：不同的时间组件生存周期。


2.GameObject：
游戏的开发不像其他软件项目，游戏这种娱乐原则上不受任何规则约束，因此在程序可以处理的前提下，任何需求的改动都是合理的。
关于为何要用ECS代替OOP的问题就不再讨论了。但按照ECS的思想，所有的对象都可以归类成GameObject类：
它的结构大致如下：
GameObject:{
	id:
	name:
	frame:	//初始帧，因为必须要渲染到场景中，至少要有一帧
	components:	//动态数据组件，map结构,key是组件的name,value是组件本身
}

可以看出，GameObject是ECS模式中的E。

3.Component:
组件是组成GameObject和Action的基础单元数据，也是供system处理的数据源，主要存储基础数据。

列举一些常用的组件：
animate:{
	type:	//静止帧、普通动画、重复动画
	frames:
	*delays:
}
motion:{
	dx:
	dy:
	factor:	//速度系数
}
hurt:{
	type:	//普通人、霸体、不倒地等等
}


4.System:
系统分为两大类：主system和ActionSystem

System主要维护自己对应的组件链表和进行update逻辑

ActionSystem是在动作节点内的逻辑操作，这些逻辑是可以并行的，有以下几种并行分类。

****动画系统需要处理以下类型：

只播放一次，完成就结束这个动作
	这里需要操作标志位以让action结束

循环播放
	结束时，frameIndex=0

最后一帧停止
	移除节点，剩下的交给其他逻辑处理（timer等）

*播放时会移动
	三段斩，第一帧移动很慢，第二帧（主判定帧移动很快），第三帧收尾帧移动很慢
	以上每帧均移动多次，移动次数和帧数无关，或许和逻辑帧帧有关，这个说的通，但如果动画变快？


****移动系统需要处理以下类型：

稳定移动
	以固定速度单向移动。

指令移动
	以固定速度单向移动，如走路、空中移动（非下落）等，方向键可改变朝向

缓动
	逐渐变慢、逐渐变快、两者混用

*随帧移动一次
	争议在于上面的 *播放时会移动，重点是在切换帧的时候执行一次，还是根据frameIndex来执行不同速度。


事件汇总：
1.单位事件
	1.1单位位置改变事件/移动
	1.2单位发起攻击
	1.3单位受到攻击
	1.4单位被加入到场景
	1.5单位死亡
	1.6单位属性改变（BUFF）
	1.7单位获得异常状态
	1.8单位受到持续性伤害

草稿4：动作特效
1.特效只做显示，不含其它逻辑
2.特效不一定和主动画同步
animate:{
	frames : [1,2,3]
	interval : 2
}
effect:{
	frames : [1,2,3,4,5]
	intervals : [2,2,3,2,3]
}

草稿5：数据格式
基础数据部分:{
	name : "deep",			//名称，用作快速查找的缓存，也是ID的前缀
	frame : "deep_stand_0.png",		//初始显示帧
	res : [res.deep_0_plist,res.deep_1_plist]	//素材引用
}
人物:{
	title : "玩家",
	action : ...		//详见下面action格式介绍
}
人物action数据格式:{
	stand : {
		animate : {
			//frames数组可以为1帧或多帧，系统判断1帧时是静态动画，多帧时是循环动画
			frames : ["deep_stand_0.png","deep_stand_1.png","deep_stand_2.png","deep_stand_3.png"],
			// interval和intervals选其一，当多帧时，interval为每帧指定同样数值，而intervals则按下标分配
			inteval : 1
			intervals : [1,1,2,1]
		}
		walk : {
			animate : {
				//同上
				frames : ["deep_run_0.png","deep_run_1.png","deep_run_2.png","deep_run_1.png"],
				inteval : 1
			},
			motion : {
				//每帧移动距离，FPS以60为主
				dx : 10,
				dy : 50
			}
		},
	}
}

5.工厂：
使用工厂接口分别对不同的数据对象进行构造：

createTile(data)
我们对tile的特征进行了一些抽象汇总，
静态或者循环动画，如静止的花和不断摆动的草
可以是，动画A-->冷却一定时间-->动画A循环

数据样式：
tile:{
	name: "obj1",
	frame: "1.png",

	*animate:{
		frames:[...]
		cd:5 //冷却5秒后继续
	}
}
从此接口创建的obj不会加入到action节点

createCharacter(data)

createBullet(data)
归纳子弹的特征：
最简单的子弹，有一个帧，朝前发射，一段距离后消失，或打中一个人后消失

扩展的子弹现象举例：
*修罗邪光斩：每个单位最多碰撞三次，每次有间隔。
*鬼印珠： 无论碰撞多少单位，总共只能碰撞20次。
*反坦克炮：命中一个单位后，会粘在其身上，一段时间后爆炸。

因此，我们能对子弹组件进行汇总抽象

*方向：一直向前、来来回回、抛物线等都需要自己执行逻辑
*速度：不解释
*有效距离/时间：生存周期咯
*碰撞：必须指定碰撞后要执行的逻辑
*结束逻辑：必须指定，一般都是子弹碰撞成功后

createSimpleBullet(data)
此接口会创建飞机游戏中最普通的子弹，即只会朝一个方向，并只命中一次的子弹。必填的数据样式：
bullet:{
	name:"",
	frame:"",
	pos:[],
	distance:,
	speed:[],
	hit:{
		animate:{}
	}
}

createGameObject(data)
如果需要创建一些特殊的，无法归类的动态object，就用此接口
比如事件触发类的彩蛋：动画A-->静止-->事件触发-->动画B
比如机关：动画A-->会攻击人的-->会消失一段时间-->重新出现-->动画A循环

createAction(data)
创建动作的接口，动作类后面会介绍


6.Action:
Action和GameObject一样，属于Entity，用于定义GameObject的动作状态，同样也同时拥有多个Component和ActionSystem。
类定义Action:{
	name:
	Map<String,Component>
	List<ActionSystem>
	next:
}


如何构成动作？

****列举一些普通的动作：

1.普通站立：
	描述：不断循环一个站立动画，可转换状态：走路、跳跃、攻击、受伤等。
	逻辑组件：animateLoop,cmd
2.走路：不断循环一个走路动画，根据方向键调整朝向，按恒定速度前进，可转换状态：站立、跳跃、攻击、受伤等。
3.攻击：动画分为三段：起手、判定、收尾。动画不循环。
4.射击：动画分为三段：起手、射击、收尾。动画不循环。子弹为独立对象，运行自己的action。
5.跳跃：动画可以是普通动画或者由逻辑控制帧，受起跳力和引力影响。

列举一些高级的动作：
1.三段斩：
2.聚焦喷火器：
3.榴弹炮：
4.精灵召唤：

列举一些复杂的动作：
1.极速飓风拳：
2.鬼影闪：
	描述：
	1.起手，此帧定时一段时间
	2.瞬移一段大距离，此时开始放出十字斩光，检测有效目标，并定住硬直
	3.过一段时间，0.5秒，
	4.发起斩击判定，有特效动画,此时人物动作已结束，解除硬直
	5.特效结束
3.幻影剑舞：


6.1公共逻辑动作
	tileStart:不加入action链表
	characterStart:人物的初始动作：stand || fall
	unitHurt:
	blockHurt:

6.2复杂动作，一些很纠结的技能猜想
	鬼影闪: 1.发起者无敌 2.目标定住一段时间 3.发起攻击 4.动作结束
	念气环绕：1.施放时间 2.判断球上限 3.发射球环绕(独立单位)
	疾风乱舞：1.前冲(有影分身特效) 2.乱舞攻击(重复3次) 3.终结攻击 4.结束动作 4以前都是无敌状态

6.3多阶段动作
	6.3.1
	施放型：1.施放前阶段，时间没到，会卡在最后一帧 2.执行阶段
	蓄力型：1.蓄力计时阶段 2.蓄力完成，指令没解除，会卡在最后一帧 3.执行

	6.3.2
	action.phase

举例：猛龙断空斩
	1.移动斩击，分为3次，每次都可改变方向，每次只判定3次攻击
	2.最后一次会浮空
	*3.某些道具加成可以增加第一阶段次数

      巨旋风
	1.蓄力，如果蓄满，第3阶段可增加两次旋转
	2.甩手，有攻击判定
	3.兵器飞出，有攻击判定，判定有时间间隔
	4.兵器旋转，有间隔攻击

6.4普通攻击动作
6.4.1 神枪手的攻击：攻击A*5，攻击B
6.4.2 格斗家的攻击：攻击A，攻击B，攻击C，攻击D
6.4.3 红眼暴走攻击：攻击A，攻击B，攻击C，攻击D
需求，神枪手可以加成，攻击A次数增加
红眼暴走加成，攻击A和攻击B可形成无线循环

目前解决方案：
	神枪手攻击A创建N个实体（根据实际加成情况），不能在运行期动态增加，使用action复制coms和sys即可。
	红眼暴走攻击B的next指向A

备选方案：ActionGroup


7.攻击类型和反馈

7.1 一个有效的攻击具备以下特征组合：
是否产生位移、是否使目标倒地、是否属于远程攻击、是否停顿帧、是否震屏
比如一个重击可能是这样组合的：位移、倒地、停顿、震屏

7.2 单位受击反馈：
设定几个hurt帧：0-1:普通  2:下落、弹起  3:平躺
unitHurt:公共逻辑动作


草稿8:攻击系统逻辑：

1.发起者碰撞hurt链表：hurt链表由hurtSystem维护，hurtCom有obj的view.sprite，用于产生rect
2.发起hit事件，封装hurt和hit(均为ownerId)
3.处理hit事件

8.1 攻击与hurtSys
6个unit需要碰撞
两两运算：6*6=36次
冒泡优化：6+5+4+3+2=20次
过滤：假如1、2是一组，3-6是一组，则 4*2=8次
从结果上看，过滤分组是运算最少的，所以碰撞必须分组

8个敌人，3个已方子弹，每帧3*8=24次碰撞检测
优化方案：偷懒运算
或者不做优化


草稿9：系统组件一览表：

motionSys - motionCom : 所有组件都会移动，判断block和地图边界

hurtSys - hurtCom: 目前仅维护列表，联动函数

animateSys - animateCom : 播放动画

actionSys - actionCom : 主节点运行

hitSys - hitCom: 主要用于做碰撞的


草稿10: 脚本引擎？

某gameObj有以下运行方案：

tile: 动画A--沉默5秒--动画A...

机关：渐渐出现--发起攻击--渐渐消失--随机位置再渐渐出现...

customObj:{
	frame:...
	actions:["a1","a2","a3"]
}
script:{
	a1->a2->a1
}

草稿35：AI和网络模块：
AI是事件反馈触发形式的，如在网络中，每个AI单位由不同设备CPU处理，发出相应指令，其他客户端不会对不是自己管控的AI发出指令，只会接收同步操作

如：客户端A发出：AIa向前走
那么，客户端B收到同步指令后，只要没收到新同步，AIa(影子)会一直执行往前走的指令，当然，碰到墙壁会卡住(本地逻辑)。收到新同步后再重新设定位置（瞬移）

延伸架构：
单位---指令---事件{单位操作，AI发送}