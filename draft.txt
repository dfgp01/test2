
***	edit by Hugo-Fu 2016.03.15 10:12 am

目录：
1.术语介绍：
	ECS
	GameObject
	Component
	System
	Action
	data：定义游戏对象的数据表格，使用json格式。
	time-scope：不同的时间组件生存周期。

2.常用组件类型介绍：
	动画类型
	移动类型
	攻击类型
	受击类型
	单位类型

3.常用系统类型介绍：
	事件类型

4.游戏对象行为杂谈：
	人物角色
	子弹
	拾取获得道具
	接触获得道具
	召唤兽
	区域

5.工厂接口：
	创建动作
	创建单位模板
	创建人物

6.数据规范：
	动作数据
	人物数据

7.主循环结构：
	动作逻辑系统
	玩家输入处理系统
	事件系统
	6.4.系统并行和串行

8.时间差：
	逻辑帧
	动画帧

9.扩展功能：
	复杂技能列举

10.简易AI：
	有限状态机

11.网络同步：
	网络协议TCP/UDP

*草稿A：DNF全技能实现方案


1.1.ECS：
实体组件系统架构，已成为开发游戏的主力设计模式

1.2.GameObject：
游戏的开发不像其他软件项目，游戏这种娱乐原则上不受任何规则约束，因此在程序可以处理的前提下，任何需求的改动都是合理的。在ECS中，没有类的概念，所有的对象都由组件组成，对象就是组件的集合。关于为何要用ECS代替OOP的问题就不再讨论了。但按照ECS的思想，对象都可以归类成GameObject类，它的结构大致如下：
GameObject:{
	id:
	name:
	frame:	//初始帧，因为必须要渲染到场景中，至少要有一帧
	components:	//动态数据组件，map结构,key是组件的name,value是组件本身
}
可以看出，GameObject是ECS中的E。

1.3.Component:
组件是组成GameObject和Action的基础单元数据，也是供system处理的数据源，主要存储基础数据。原则上，组件不处理逻辑。

1.4.System
系统是运行对应组件逻辑的处理器，它不存储数据，只运行逻辑，因此，每个系统只会有一个实例。
目前系统分为两大类：主循环system和ActionSystem，主循环System主要维护自己对应的组件链表和进行update逻辑，ActionSystem是在一个动作节点内对组件的逻辑操作。

1.5.Action
表示一个单位的动作状态节点，每个动作由多个独立的组件和系统构成。


2.1.动画类型

	只播放一次，完成就结束这个动作，这里需要操作标志位以让action结束

	只播放一次后隐藏，比如一些动作特效。

	循环播放，结束时，frameIndex=0

	最后一帧停止，移除节点，剩下的交给其他逻辑处理（timer等）

	*播放时会移动，例如三段斩，第一帧移动很慢，第二帧（主判定帧移动很快），第三帧收尾帧移动很慢，以上每帧均移动多次，移动次数和帧数无关，或许和逻辑帧帧有关，这个说的通，但如果动画变快？


2.2.移动类型

	稳定移动，以固定速度单向移动。

	*指令移动，以固定速度单向移动，如走路、空中移动（非下落）等，方向键可改变朝向

	*指令移动2，逻辑同上，但只改变运动方向，不改变朝向

	缓动，逐渐变慢、逐渐变快、两者混用

	*随帧移动一次，争议在于上面的 *播放时会移动，重点是在切换帧的时候执行一次，还是根据frameIndex来执行不同速度。


3.1.事件类型
1.单位事件
	1.1单位位置改变事件/移动
	1.2单位发起攻击
	1.3单位受到攻击
	1.4单位被加入到场景
	1.5单位死亡
	1.6单位属性改变（BUFF）
	1.7单位获得异常状态
	1.8单位受到持续性伤害
	1.9单位进入/离开区域

4.2.子弹

最简单的子弹，只有一帧，稳定向前，没打中人的话，飞行一段距离后消失/或者是持续一段时间后消失，或打中一个人后，播放击中动画后消失/也可以是系统特效。
复杂的子弹现象举例：
*修罗邪光斩：每个单位最多碰撞三次，每次有间隔。无动画
*鬼印珠： 无论碰撞多少单位，总共只能碰撞20次。有个循环动画
*反坦克炮：命中一个单位后，会粘在其身上，一段时间后爆炸。

因此，我们能对子弹组件进行汇总抽象

*方向：一直向前、来来回回、抛物线等都需要自己执行逻辑
*速度：不解释
*有效距离/时间：生存周期咯
*碰撞：必须指定碰撞后要执行的逻辑
*结束逻辑：必须指定，一般都是子弹碰撞成功后


5.1.动作数据
action:{
	name:"stand",
	animate:{
		type:1,
		frames["1.png","2.png","3.png"],
		interval:0.3
	},
	motion:{
		dx:1.2,
		dy:0
	}
}

5.2.人物数据
character:{
	frame:"1.png",
	name:"hero",
	motion:{
		basic
	}
	stand:{
		frames["1.png","2.png","3.png"],
		interval:0.3,
		switchable:["walk","hit","jump"]
	},
	actions:[...]
}

6.1动作逻辑系统
ActionUpdataSystem主要负责遍历所有actions节点，执行aciton.update(dt)。
action的执行分为三个阶段：start(unit),update(dt,unit),end(unit)
关于end部分，虽然大部分组件在start中初始化，但有些组件是需要运行end的，比如一个喷火动作，突然被打断，那么特效是要随之消失的。

草稿：动作特效
1.特效只做显示，不含其它逻辑
2.特效不一定和主动画同步
animate:{
	frames : [1,2,3]
	interval : 2
}
effect:{
	frames : [1,2,3,4,5]
	intervals : [2,2,3,2,3]
}

5.工厂：
使用工厂接口分别对不同的数据对象进行构造：

createBullet(data)


createSimpleBullet(data)
此接口会创建飞机游戏中最普通的子弹，即只会朝一个方向，并只命中一次的子弹。必填的数据样式：
bullet:{
	name:"",
	frame:"",
	pos:[],
	distance:,
	speed:[],
	hit:{
		animate:{}
	}
}

createGameObject(data)
如果需要创建一些特殊的，无法归类的动态object，就用此接口
比如事件触发类的彩蛋：动画A-->静止-->事件触发-->动画B
比如机关：动画A-->会攻击人的-->会消失一段时间-->重新出现-->动画A循环

createAction(data)
创建动作的接口，动作类后面会介绍


6.Action:
Action和GameObject一样，属于Entity，用于定义GameObject的动作状态，同样也同时拥有多个Component和ActionSystem。
类定义Action:{
	name:
	Map<String,Component>
	List<ActionSystem>
	next:
}


如何构成动作？

****列举一些普通的动作：

1.普通站立：
	描述：不断循环一个站立动画，可转换状态：走路、跳跃、攻击、受伤等。
	逻辑组件：animateLoop,cmd
2.走路：不断循环一个走路动画，根据方向键调整朝向，按恒定速度前进，可转换状态：站立、跳跃、攻击、受伤等。
3.攻击：动画分为三段：起手、判定、收尾。动画不循环。
4.射击：动画分为三段：起手、射击、收尾。动画不循环。子弹为独立对象，运行自己的action。
5.跳跃：动画可以是普通动画或者由逻辑控制帧，受起跳力和引力影响。

列举一些高级的动作：
1.三段斩：
2.聚焦喷火器：
3.榴弹炮：
4.精灵召唤：

列举一些复杂的动作：
1.极速飓风拳：
2.鬼影闪：
	描述：
	1.起手，此帧定时一段时间
	2.瞬移一段大距离，此时开始放出十字斩光，检测有效目标，并定住硬直
	3.过一段时间，0.5秒，
	4.发起斩击判定，有特效动画,此时人物动作已结束，解除硬直
	5.特效结束
3.幻影剑舞：


6.1公共逻辑动作
	tileStart:不加入action链表
	characterStart:人物的初始动作：stand || fall
	unitHurt:
	blockHurt:

6.2复杂动作，一些很纠结的技能猜想
	鬼影闪: 1.发起者无敌 2.目标定住一段时间 3.发起攻击 4.动作结束
	念气环绕：1.施放时间 2.判断球上限 3.发射球环绕(独立单位)
	疾风乱舞：1.前冲(有影分身特效) 2.乱舞攻击(重复3次) 3.终结攻击 4.结束动作 4以前都是无敌状态

6.3多阶段动作
	6.3.1
	施放型：1.施放前阶段，时间没到，会卡在最后一帧 2.执行阶段
	蓄力型：1.蓄力计时阶段 2.蓄力完成，指令没解除，会卡在最后一帧 3.执行

	6.3.2
	action.phase

举例：猛龙断空斩
	1.移动斩击，分为3次，每次都可改变方向，每次只判定3次攻击
	2.最后一次会浮空
	*3.某些道具加成可以增加第一阶段次数

      巨旋风
	1.蓄力，如果蓄满，第3阶段可增加两次旋转
	2.甩手，有攻击判定
	3.兵器飞出，有攻击判定，判定有时间间隔
	4.兵器旋转，有间隔攻击

6.4普通攻击动作
6.4.1 神枪手的攻击：攻击A*5，攻击B
6.4.2 格斗家的攻击：攻击A，攻击B，攻击C，攻击D
6.4.3 红眼暴走攻击：攻击A，攻击B，攻击C，攻击D
需求，神枪手可以加成，攻击A次数增加
红眼暴走加成，攻击A和攻击B可形成无线循环

目前解决方案：
	神枪手攻击A创建N个实体（根据实际加成情况），不能在运行期动态增加，使用action复制coms和sys即可。
	红眼暴走攻击B的next指向A

备选方案：ActionGroup


7.攻击类型和反馈

7.1 一个有效的攻击具备以下特征组合：
是否产生位移、是否使目标倒地、是否属于远程攻击、是否停顿帧、是否震屏
比如一个重击可能是这样组合的：位移、倒地、停顿、震屏

7.2 单位受击反馈：
设定几个hurt帧：0-1:普通  2:下落、弹起  3:平躺
unitHurt:公共逻辑动作


草稿8:攻击系统逻辑：

1.发起者碰撞hurt链表：hurt链表由hurtSystem维护，hurtCom有obj的view.sprite，用于产生rect
2.发起hit事件，封装hurt和hit(均为ownerId)
3.处理hit事件

8.1 攻击与hurtSys
6个unit需要碰撞
两两运算：6*6=36次
冒泡优化：6+5+4+3+2=20次
过滤：假如1、2是一组，3-6是一组，则 4*2=8次
从结果上看，过滤分组是运算最少的，所以碰撞必须分组

8个敌人，3个已方子弹，每帧3*8=24次碰撞检测
优化方案：偷懒运算
或者不做优化


草稿9：系统组件一览表：

motionSys - motionCom : 所有组件都会移动，判断block和地图边界

hurtSys - hurtCom: 目前仅维护列表，联动函数

animateSys - animateCom : 播放动画

actionSys - actionCom : 主节点运行

hitSys - hitCom: 主要用于做碰撞的


草稿10: 脚本引擎？

某gameObj有以下运行方案：

tile: 动画A--沉默5秒--动画A...

机关：渐渐出现--发起攻击--渐渐消失--随机位置再渐渐出现...

customObj:{
	frame:...
	actions:["a1","a2","a3"]
}
script:{
	a1->a2->a1
}

草稿35：AI和网络模块：
AI是事件反馈触发形式的，如在网络中，每个AI单位由不同设备CPU处理，发出相应指令，其他客户端不会对不是自己管控的AI发出指令，只会接收同步操作

如：客户端A发出：AIa向前走
那么，客户端B收到同步指令后，只要没收到新同步，AIa(影子)会一直执行往前走的指令，当然，碰到墙壁会卡住(本地逻辑)。收到新同步后再重新设定位置（瞬移）

延伸架构：
单位---指令---事件{单位操作，AI发送}


草稿A：系统实现DNF全技能方案

1.所有人
	站立：循环动画、可切换动作、默认初始动作
	走路/跑步：循环动画、指令移动1、可切换动作
	跳跃：*逻辑控制帧、指令移动1、可切换攻击动作1次、重力下落、初始化起跳力、跳前要下蹲
	受身蹲伏：指令松开或者持续一段时间后结束、期间无敌。
2.鬼剑士
	攻击：普通攻击（后退）、指令判断前移、可切换下一个攻击、可切换其他技能
	上挑：普通攻击（倒地）、指令判断前移、起手和判定阶段为霸体，收尾阶段取消霸体
	三段斩：分为三个动作，因为每个动作都需要按键、都需要消耗MP。指令判断方向、分阶段移动
	鬼斩：逻辑类似上挑、有特效、有附加异常状态


软件项目层次：

引擎底层
	cocos2d-js引擎
	EngineUtil接口,app.js,ui组件嵌入的事件等

逻辑层(ECS架构)
	GameObject,Action,Component,ActionSystem,System
	MainSystem负责主循环

业务接口层（这里可以开始使用OOP开发）
	Service,Factory,SimpleFactory

UI组件层
	ControllerLayer,Button,Arrows

数据脚本层（使用Json或xml等协议预言定义）
	gobal.js,data.js,character.js


传统搓招指令
如，一个技能的施放顺序：←↓→+A（后下前+攻击）
我用三位二进制数表示方向，000代表右，001代表左。。。111代表右下等等
然后用一个变量存储历史方向按键，比如左右左就是 001000001=65
但是别忘了右方向是000，如果放在前面则没有任何意义，所以我们在变量前加个1作头:1001000001=577
由于数值有上限，所以我只用了16位二进制，最大数值为：65535，也就是最多可以存储5个连续方向指令
在按下方向键的时候，判定是否连续按键，根据计算两次按键间隔来确定是否满足条件，如果满足，则使用逻辑运算追加到变量中：
第一次：command = 001（按下了左键），则 key = 1<<3 + command; //9
第二次：command = 000（按下了右键），则 key = key<<3 + command; //72
第三次......
但是要注意，上限是16位，所以在连续按键中，还需要判断是否超过了最大连续按键，如果超过，就要舍弃最早的按键，加入最新的按键
假设已经按下了5次左：key=37499; //1001 0010 0100 1001
然后再按下了一次右：command=0; //000
进行最高位判断if(key&32768) //32768 = 1000 0000 0000 0000，另外这里的运算符是&，不是&&，我没写错
条件成立，就执行：key = 32768+((key&4095)<<3)+command; //4095=0000-111-111-111-111


连续指令的拆解：
如果玩家输入：←↓→+A，系统需要进行连续判断，当找不到←↓→，就找↓→，再到→这样。
第一次：command = 1001011000;
找不到时，需要定位最高位，由于最高位1只会是2^15=32768, 2^12=4096, 2^9=1024, 2^6=64, 2^3=8这几种情况，用一个循环就能确定。
这里的最高位是1000000000=1024;
第二次：command = 1011000;舍去了最高位后面的001，计算过程是:
1. 1024-1=111111111>>3=111111;
2. 111111 & 1001011000 = 11000;
3. 1024+11000 = 1011000; 最终结果，以此类推。