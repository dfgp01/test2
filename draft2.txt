
主循环中的系统组件：
{
	actionSystem: 所有action单位，update当前action，很重要
	viewSystem:	渲染系统，更新帧，更新坐标，FPS=24
	timerSystem:	更新所有计时器
	*musicSystem:	bgm要一直放
}

viewSystem:渲染系统
FPS=24，与主逻辑FPS=60异步，24帧这个数值以实际情况调整
两个链表维护，一个管理animateCom，一个管理moveCom，用链表是为了灵活增删。
如果只用一个链表管理所有unit，再通过判断去执行是否更新渲染，时间复杂度可能会稍微增加，但影响可能不大，需要一定数量单位测试。
需求问题：如果画面发生整体平移（卷轴算法），那么此时所有unit（除主角）都要进行位置更新，都加上一个平移量，那么此时moveCom链表的数据不全
解决方案：发生平移时，渲染系统另外全局更新所有unit:{ viewCom.x += vx;};但是这样会发生重复drawcall，因为之前的moveCom列表已经更新过坐标
	鉴于现在对tilemap了解甚少，此问题需要研究cocos的渲染机制，移动整个layer的时候内部是如何进行的。


动作切换流程，action1.end->action2.start需要做什么事情：
1.end内，相关的coms移除并初始化，如moveCom移出渲染系统，同时moveCom.vx=0;
2.start内，相关coms赋值，如unit.moveCom.vx = action.moveCom.vx; 并加入到渲染系统
问题：如果action1和action2都拥有同类别的com，如moveCom，那么在action1.end时将moveCom向量清零并移出渲染系统，然后在action2.start中又重新赋值并加入渲染系统，是否冗余操作？
解决：目前暂没有更好的解决方案，因两个action之间无法确定coms关系，所以采用链表是为了更好的应对频繁的增删操作。action1.end中必须将moveCom向量清零，虽然action2中不一定有moveCom即不会加入到渲染系统中更新坐标，但有可能在进行整体画面平移的时候，vx的值会被污染。假设画面平移2px，此时unitA不动，应该是vx+=2，但如果unitA在上一个有moveCom的action中没有清除vx，那么平移时将产生错误量。


移动组件数据改变的流程：
定格：viewSystem只用单调的代码去重绘坐标：
	viewCom.sprite.setPostion(
		viewCom.sprite.getPostionX + moveCom.dx * viewCom.vx,
		viewCom.sprite.getPostionY + moveCom.dy);
匀速移动action:
	action.update->moveSys.update(dt){ unit.moveCom.dx = moveCom.dx; }
步行指令action:
	action.update->moveSys.update(dt){ if(cmd=1)unit.moveCom.dx = moveCom.dx + moveCom.buff; else if(cmd=2)........}
获得加速10%buff:
首先要明确加速会影响哪些地方？
走路/跑步移动增量、普通攻击频率、以上动作的动画帧播放速度，暂时这么多。
由此可见，速度BUFF只在特性action中有效。因此只能从这些action内入手。

actionSystem:动作运行系统
这是最为核心的系统，因为每个unit都会拥有至少一个action
此系统轮询所有unit，并update其currAction.sysList。
假设目前一个action仅有两个逻辑：不断移动和播放动画。


生产者消费者模式？
actionSystem运行在FPS=60中
	在确定更新了moveCom后，将moveCom添加至渲染move队列
	在确定更新了frame后，将viewCom添加至渲染frame队列
然后在viewSystem中消费队列
好处是不用判断if(frame==lastFrame)之类的，时间复杂度有所减少。
缺点是设计更复杂。

TimerSystem:计时系统
计时组件一般就做倒计时用，倒计时完成后的回调接口要放在哪里运行？


Node与Com的关系：
1.Node{
	Node prep
	Node next
	Object com
}

2.Com{
	...其他com属性
	Node node
}

第一种，Node包含Com，对com的耦合性及侵入性较小，灵活配置
第二种，Com包含Node，结构侵入性大
需求问题：确定所有链表增删操作时，对Node的定位。
如渲染系统遍历节点时，链表结构是Node或Com时，复杂度是等价的。
do{ update(com);}while(com.node.next)
do{ update(node.com);}while(node.next)
如果一个com被多个链表引用？则com含有node结构不可取
最全解决方案：相互耦合，即Node含有Com，Com也含有Node，但要保证Node和Com是一对一关系

actionSystem中维护一个actionCom链表，几乎是所有单位
update遍历 : if(currNode.需要更新帧){ viewCom加入渲染队列中 }

animateSystem消费队列，update上面的viewCom。然后再踢出队列


单位死亡逻辑：
一般情况下，系统清除单位流程如下：
deadAction->endAction->reback_to_template
一个人形的单位deadAction可以表示为：躺在地上，闪烁片刻，惨叫一声
endAction一般逻辑为：将unit送回到对象池队列中。所以在endAction执行前，所有的com都必须保证已从执行队列中踢出。比如moveCom已停止移动，sprite已不再显示等。

单位转入死亡状态前，包含但不限于以下情况：
1.受到普通攻击：该攻击不倒地，但角色需要立即转入倒地动作，然后执行deadAction
2.受到倒地攻击：角色要在倒地后才执行deadAction
3.受到特殊攻击：比如被击后需要晕眩一段时间的，但由于已达死亡条件，因此需执行倒地动作，执行deadAction
4.系统发出其他杀死事件

因此，在deadAction前驱是一个强制倒地动作。（仅对有倒地的单位而言）
即使单位以何种方式死亡，统一都是由系统发出死亡事件，所以可以从死亡类型属性中决定倒地动作等。
在伤害判断系统中，已有攻击类型或受击类型等信息，可将数据通信到死亡消息中。


C/S端大致上的数据流转逻辑过程：（目前网路通信部分暂无，服务端由客户端模拟，但大致流程不变）

ClientA=客户端A
ServerA=服务端A，这里由客户端A兼任
UnitA
UnitB

1.ClientA中新增一个UnitA
1.1 ClientA发送单位创建事件
1.1x ServerA消费并广播此单位创建事件（异步）
1.2 ClientA执行创建逻辑，因为是由ClientA本机发出，故后面的相关逻辑都不用等Server广播事件，可以先一步执行，其他Client则要等收到广播后才执行
	unitA.create{
		coms初始化，细节略
		viewCom.sprite->addToLayer(); startAction.start(actionCom);
	}

1.3 ClientA.unitA添加到舞台后，将开始执行action主逻辑轮询：
	actionSys.start(actionCom){
		1.ClientA发送事件：unitA切换了action
		2.加入到actionSys运行节点：{ node = getNodeFromIdleQuene; node.com=actionCom; node->addToQuene;}
	}

1.4 ServerA执行消息队列：
1.4.1 经过上面的步骤，现在ServerA队列里应有以下消息：
	1.unitA被创建了
	执行相关监听器，以下是主监听器：
		1.1 ServerA创建unit:
			unitA.create{
				coms初始化，细节略
				Server保存逻辑（后续写详细）
			}
		1.2 广播到所有Client，包括坐标等信息。
	2.unitA切换action:stand，主要是广播操作，更新属性值等

2.第二逻辑帧
2.1 actionSys执行逻辑：
	actionSys.update{
		//loop list
		累加帧计时，判断是否需要更新帧
		更新移动向量
	}


不同系统的逻辑流程：
渲染系统：采用队列式，即时消费，判断是否更新帧的逻辑在action中完成，此系统负责重绘。
移动系统：如果采用队列式，会做很多重复运算，假设一个物体每帧平移1px，每帧反复在队列上增删是相当冗余。
	因此这里采用链表式，无需判断vx等向量是否为0
计时系统：采用链表式，每帧累计时间，到点后踢出链表。
碰撞系统：需详细设计


离散的数据结构：

举个栗子，一个金刚罩，保护进入该区域的已方单位（无敌状态），持续7秒，能承受一定量的伤害，结构如下：
1.它是一个独立的被召唤单位，因为技能吟唱后，释放者可自由活动，如果不能活动，那它的生命周期应由action.timer来决定。
2.有动画，不会位移。
3.区域碰撞检测，判断单位是否友军组，进入或离开时更新目标状态。
4.可承受伤害，可被攻击，所以要有hurtCom
5.一定时间后消失，有timerCom，timerCom绑定一个action

10.01---日志

GameObject数据结构已做好，组件采用Map存储Componenets<name, com>
如果gameObj有 components.liveTime，
那么在合适时机将components.liveTime组件写到TimerSys，然后再加入TimerSysMgr
移除的时候同理
其他组件同理

外挂特效的思路：
外挂特效（以下用obj）拥有一个Sprite，但obj有一个owner组件
obj只需要知道owner当前的动作信息，便可以调整相应动画（owner每次变换动作都会发事件）


***
监控系统 MonitorSystem {
	update(dt){
		//监控活动对象，可以是当手指触摸一个obj时，实时显示它的状态
	}
}


2016.09.21

--离散结构

单位-组件-逻辑

单位是组件的复合体，每种类型的组件只会有一个
一个组件对应一个逻辑元件

调度器：一个调度器管理多个同类型的逻辑元件

举例：MoveComponent

公共：{
	vx : 0, vy : 0, type : 1
}

其他类型的运动组件属性在子类添加。

根据type不同，对应不同的逻辑元件
例如：匀速直线运动、线性运动(渐慢到停止)

MoveSystem:{
	list : 多个move逻辑单元遍历
}
主调度器调用moveSystem，主调度器采用链表方式，因为会随时进行增删操作

逻辑单元应该用工厂和对象池管理(template)
每次取一个逻辑单元，对应一个组件


归纳数据结构算法到项目的应用：

网格和图：
寻路，一般用于RTS中，因为网格数量巨大，如果单纯使用全局A*算法，性能开销巨大。
如果将地图划分若干个区域，区域间用图算法，区域内网格用A*算法，可优化运算效率。
不知其他地方可否运用这个思想。

平衡二叉树：
快速查找区间内的对象。
实例：如果将所有单位用等级来排序，若要筛选指定等级间的单位集合，其实采用列表存储和二分法就可以，但若单位需要频繁增删，则使用平衡二叉树。


快速索引研究：
需求问题：
1.场景内有大量单位：500个battle_unit
2.避免频繁遍历所有单位，需要精准筛选具有相同属性的单位。
3.不定时增删。

满足1,2,3时，可用平衡二叉树
根据一种属性（权）创建一种索引（一棵树）
如等级，每个等级为一个节点，等级值=权，每个节点内有一个集合存储单位。
同理，权值可以是其他属性：抗性类型、攻击模式等等。
单位生命周期改变时需要维护索引。


需要加入每帧判断的：
move: 结束后踢出sys
anim: 结束后踢出sys
collide:

单位移除事件：（死亡时）
将Entity放到对象池中。
将entity所有com都踢出sys


关联式的组件生命周期流程管理：

场景1：单位A召唤N个召唤兽。
1.进入召唤action。
2.从对象池中生成并初始化召唤单位。
	2.1召唤兽运行standaction
	2.2召唤兽监听单位A死亡事件。
3.动作结束，切换standAction

场景2：单位A释放一个BUFF技能，该技能显示效果中有个外挂特效在A身上。
1.进入action，吟唱阶段。
2.从对象池中生成并初始化特效显示单位。
	2.1特效单位进入action，通常是一个loop-animate
	2.2特效单位监听单位A死亡事件。

场景3：A正在执行射击动作，发射了三枚子弹和一枚火箭
.....细节省略

场景4：单位A死亡（系统发出kill事件）
1.单位A向后飞（一般的死亡动画）
2.单位躺地上闪烁并啊一声（此时move组件应该已从sys中下架）
3.单位执行endAction. 移除animateCom，visible=false，单位回归对象池，其他组件理应下架。
4.向所有监听单位A死亡事件的单位发送kill事件。各自执行endAction，这一条和123条是异步执行的。


瓶颈观察：
先全跑60FPS，再查看资源性能问题。逻辑60FPS，渲染就依然24FPS。

每帧逻辑系统：
	action: 轮询actionCom组件，几乎是所有单位。
	move: 轮询moveCom组件，只要vx,vy=0的就马上踢出链表
	collide: 轮询collide组件，注意和attack的区别
	event: 消费消息队列


数据结构：

template:存储原始属性，对象池
	coms集合{}
	可用对象队列（对象池）

action:
	coms列表，使用列表结构而非map结构
	sys列表
	update(){	遍历sys列表}

举例，运动逻辑系统，*号表示此步骤存在争议，或许可以省略。
可运动型单位有moveCom组件：{vx,vy}，当然，也有显示组件：{x,y,frame...}
action有moveCom组件：{type,vx,vy}
action有moveSys逻辑，根据type决定具体程序细节：{vx++,if(终止条件)......}
*mainLoop有个moveSys总系统，负责更新所有单位的坐标：{a.vx+=vx..., b.vx+=vx...}
渲染系统要更新运动单位的坐标。

渲染系统需要做两件事
1.更新单位动画帧
2.更新单位坐标
全场单位相对于渲染系统，有四种状态：
1.不需要更新动画帧且不更新坐标
2.只需要更新动画帧
3.只需要更新坐标
4.需要更新动画帧和坐标

方案：
分别维护两个链表，每次分别更新帧和坐标
不知对drawcall是否造成浪费
因为即使采取何种数据结构，sprite.setPosition()和sprite.setFrame()都会造成两次drawcall

动作切换的程序流程：
action1.end时，会将moveCom移出mainMoveSys
action2.start时，如果含有moveCom，则会再将moveCom添加进mainMoveSys
虽然采用链表机制，但也许是种浪费。