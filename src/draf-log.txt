#2015.04.13

Unit类的group、mask说明：
数据格式为二进制，group用于碰撞检测的逻辑判断，mask用于AttackActionState和Unit的攻击类型判断。

group用例：1、2、4、8等，是组号
mask用例：1为普通击退，2为普通击飞等


###	主要逻辑说明		###

1.主体结构简单说明:
1.1	service层：
			Factory类：构建组件并添加到Container容器中
			Container类：主容器类，存储初始化后的组件到内存中，便于重新构建，不需再读文件。
			Pool类：对象池，用于主循环时对象复用，和Container不同概念。Container存储定义，Pool存储对象。
			Util类：工具类，提供通用方法。
			
1.2	action层：
			ActionState类：每一个种类的unit所有实例对应一个template，template存储该种类的ActionState。
			ActionState负责播放动画、存储数据组件和系统逻辑，按顺序并排调用，相当于一个逻辑函数序列容器。
			
1.3	unit层：
			GameObject：一切游戏元素的基类，有基本属性和不同的组件，根据ECS设计模式，应该不会有派生类。
			UnitTemplate类：负责存储单位类型的具体数据组件，供单位创建和初始化。


###	2015.05.09	###

动作释放类型：瞬发、施放、蓄力、施放后蓄力
动作播放类型：顺播、循环、最后一帧静止、自定义（需逻辑实现）
攻击目标检测：敌军、友军、自身、自身及友军
攻击目标数量：1个、全体(99)、具体数量
攻击方式：一次，固定次数，固定间隔(持续时间)
击中后处理：mask定义具体动作
击中附加处理：函数列表

a punch:
			攻击方：1. hp - 100	2.中毒5s, 每秒-10hp	3. 2%几率晕眩2s
			防御方：1. 物理免疫	2.中毒减轻					3. 反伤10%	4. 10%几率放出2只复仇机器人
		解决方案:
			1.将中毒晕眩等逻辑先忽略。
			2.每个attEffect都运行hurtEffect，再运行state
		
		att传输到hurt的data参考：
		{
			power : 20,
			晕 : {
				jilv: 2%,
				time : 5
			}
		}
		
		
###		2015.11.11	###

一些动作拆解的推算：

狂乱锤击：
	动作分为以下几个阶段：
		1.快速砸地
		2.以上动作可重复3-5次，需按攻击指令实现
		3.大力砸地，速度比之前的慢很多
		4.以上动作全程霸体
	需求变更：快速砸地动作次数可增加

圣职者的落凤锤：
	动作分为以下几个阶段：
		1.起跳，vec向上，空中可被打断
		2.下落前的过渡动作，一或多帧的动画，空中可被打断
		3.下落中，可被打，状态为霸体，帧固定，可攻击，类型为硬直后退
		4.碰地，震荡波，范围攻击，类型为直线向上浮空倒地，本体硬直一段时间
		5.结束，变为stand动作
	需求变更：起跳下落的高度不可变，速度不可变。3-4阶段的击中后可增加其他BUFF效果，结束前硬直时间可缩短
	
机械师的机械复仇：
	动作分为以下几个阶段：
		1.被打时有一定几率触发，若已触发，执行以下流程。（是被攻击系统触发，不是碰撞系统）
		2.执行被击的动作，召唤指定的单位。（召唤的单位执行自己的逻辑）
	需求变更：可根据几率或等级改变单位种类和数量，但不建议同时召唤两种或以上的单位。
					不能将被打动作改为霸体或无敌，影响平衡。
					
聚焦喷火器：
	动作分为以下几个阶段：
		1.拔枪动作，由一段动画组成，人物不可动。
		2.开始喷火攻击，接受移动指令。攻击方式为间隔攻击，击中硬直后退
		3.如果放开攻击键或已持续7秒，则停止
	需求变更：攻击间隔计算不可缩短，影响性能。
					移动速度可增加，持续时长可增加。
					
背摔：
	动作分为以下几个阶段：
		1.可在原地或跑动过程中执行，检测碰撞而不是攻击判定
		2.碰撞成功后，执行背摔动作，而目标单位也要随逻辑一起执行
		3.背摔动作中的某帧发起攻击判定
		4.这个动作的逻辑难度大
	
抛投：
螺旋彗星落：

关于动作被打断：
	如 unitA 正在执行actionA，此action可能有5个sys组成，unitA到sys3的流程中被其他原因打断，需进入另一个action。
	但最后还是会继续执行actionA的sys4,sys5，这样可能会引发一系列的问题，解决方案是每个动作都有state属性，动作
	在执行完之后会按照state和nextAction去判定下一Action的问题。